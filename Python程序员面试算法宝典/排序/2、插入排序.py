"""
从剩余的元素中,拿出第一个,与应该插入位置的元素进行交换,同时该位置以后的元素都向后移动一位.

    在查找位置的时候,可以使用二分查找

插入排序是一种稳定的排序方法,
    最好情况下的时间复杂度为O(N),
    最坏情况下的时间复杂度为O(N*N),
    平均情况下的时间复杂度为O(N*N),


    空间复杂度为O(1)
"""


def insert_sort(lists):
    print('排序前:', lists)
    count = len(lists)
    # 第一个元素按已经排序处理,从第2个开始
    for i in range(1, count):
        key = lists[i]  # 剩余元素开始的位置

        # 找到应该插入已经排好序的数组的位置,从后往前找
        j = i - 1
        while j >= 0:
            if lists[j] > key:  # key和最后面大的交换位置,直到找到合适的位置
                lists[j + 1] = lists[j]
                lists[j] = key
            j -= 1
        print('排序中:', lists)

    print('排序后:', lists)


if __name__ == '__main__':
    insert_sort([3, 4, 2, 8, 9, 5, 1])
"""
排序前: [3, 4, 2, 8, 9, 5, 1]
排序中: [3, 4, 2, 8, 9, 5, 1]
排序中: [2, 3, 4, 8, 9, 5, 1]
排序中: [2, 3, 4, 8, 9, 5, 1]
排序中: [2, 3, 4, 8, 9, 5, 1]
排序中: [2, 3, 4, 5, 8, 9, 1]
排序中: [1, 2, 3, 4, 5, 8, 9]
排序后: [1, 2, 3, 4, 5, 8, 9]
"""
